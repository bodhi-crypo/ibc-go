"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9310],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(t),u=r,g=h["".concat(s,".").concat(u)]||h[u]||d[u]||i;return t?a.createElement(g,o(o({ref:n},c),{},{components:t})):a.createElement(g,o({ref:n},c))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[h]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},35090:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const i={title:"Channel Upgrades",sidebar_label:"Channel Upgrades",sidebar_position:6,slug:"/ibc/channel-upgrades"},o="Channel Upgrades",l={unversionedId:"ibc/channel-upgrades",id:"ibc/channel-upgrades",title:"Channel Upgrades",description:"Learn how to upgrade existing IBC channels.",source:"@site/docs/01-ibc/06-channel-upgrades.md",sourceDirName:"01-ibc",slug:"/ibc/channel-upgrades",permalink:"/main/ibc/channel-upgrades",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Channel Upgrades",sidebar_label:"Channel Upgrades",sidebar_position:6,slug:"/ibc/channel-upgrades"},sidebar:"defaultSidebar",previous:{title:"Genesis Restart Upgrades",permalink:"/main/ibc/upgrades/genesis-restart"},next:{title:"Governance Proposals",permalink:"/main/ibc/proposals"}},s={},p=[{value:"Channel Upgrade Handshake",id:"channel-upgrade-handshake",level:2},{value:"Initializing a Channel Upgrade",id:"initializing-a-channel-upgrade",level:2},{value:"Governance gating on <code>ChanUpgradeInit</code>",id:"governance-gating-on-chanupgradeinit",level:3},{value:"Cancelling a Channel Upgrade",id:"cancelling-a-channel-upgrade",level:2}],c={toc:p},h="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(h,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"channel-upgrades"},"Channel Upgrades"),(0,r.kt)("admonition",{title:"Synopsis",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Learn how to upgrade existing IBC channels.")),(0,r.kt)("p",null,"Channel upgradability is an IBC-level protocol that allows chains to leverage new application and channel features without having to create new channels or perform a network-wide upgrade. "),(0,r.kt)("p",null,"Prior to this feature, developers who wanted to update an application module or add a middleware to their application flow would need to create a new channel in order to use the updated application feature/middleware, resulting in a loss of the accumulated state/liquidity, token fungibility (as the channel ID is encoded in the IBC denom), and any other larger network effects of losing usage of the existing channel from relayers monitoring, etc."),(0,r.kt)("p",null,"With channel upgradability, applications will be able to implement features such as but not limited to: potentially adding ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/discussions/719"},"denom metadata to tokens"),", or utilizing the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/main/spec/app/ics-029-fee-payment"},"fee middleware"),", all while maintaining the channels on which they currently operate."),(0,r.kt)("p",null,"This document outlines the channel upgrade feature, and the multiple steps used in the upgrade process."),(0,r.kt)("h2",{id:"channel-upgrade-handshake"},"Channel Upgrade Handshake"),(0,r.kt)("p",null,"Channel upgrades will be achieved using a handshake process that is designed to be similar to the standard connection/channel opening handshake."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type Channel struct {\n  // current state of the channel end\n  State State `protobuf:"varint,1,opt,name=state,proto3,enum=ibc.core.channel.v1.State" json:"state,omitempty"`\n  // whether the channel is ordered or unordered\n  Ordering Order `protobuf:"varint,2,opt,name=ordering,proto3,enum=ibc.core.channel.v1.Order" json:"ordering,omitempty"`\n  // counterparty channel end\n  Counterparty Counterparty `protobuf:"bytes,3,opt,name=counterparty,proto3" json:"counterparty"`\n  // list of connection identifiers, in order, along which packets sent on\n  // this channel will travel\n  ConnectionHops []string `protobuf:"bytes,4,rep,name=connection_hops,json=connectionHops,proto3" json:"connection_hops,omitempty"`\n  // opaque channel version, which is agreed upon during the handshake\n  Version string `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`\n  // upgrade sequence indicates the latest upgrade attempt performed by this channel\n  // the value of 0 indicates the channel has never been upgraded\n  UpgradeSequence uint64 `protobuf:"varint,6,opt,name=upgrade_sequence,json=upgradeSequence,proto3" json:"upgrade_sequence,omitempty"`\n}\n')),(0,r.kt)("p",null,"The version, connection hops, and channel ordering are fields in this channel struct which can be changed. For example, the fee middleware can be added to an application module by updating the version string ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/995b647381b909e9d6065d6c21004f18fab37f55/modules/apps/29-fee/types/metadata.pb.go#L28"},"shown here"),". However, although connection hops can change in a channel upgrade, both sides must still be each other's counterparty. This is enforced by the upgrade protocol and upgrade attempts which try to alter an expected counterparty will fail."),(0,r.kt)("p",null,"On a high level, successful handshake process for channel upgrades works as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The chain initiating the upgrade process will propose an upgrade."),(0,r.kt)("li",{parentName:"ol"},"If the counterparty agrees with the proposal, it will block sends and begin flushing any in-flight packets on its channel end. This flushing process will be covered in more detail below."),(0,r.kt)("li",{parentName:"ol"},"Upon successful completion of the previous step, the initiating chain will also block packet sends and begin flushing any in-flight packets on its channel end. "),(0,r.kt)("li",{parentName:"ol"},"Once both channel ends have completed flushing packets within the upgrade timeout window, both channel ends can be opened and upgraded to the new channel fields. ")),(0,r.kt)("p",null,"Each handshake step will be documented below in greater detail."),(0,r.kt)("h2",{id:"initializing-a-channel-upgrade"},"Initializing a Channel Upgrade"),(0,r.kt)("p",null,"A channel upgrade is initialised by submitting the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChanUpgradeInit")," message, which can be submitted only by the chain itself upon governance authorization. This message should specify an appropriate timeout window for the upgrade. It is possible to upgrade the channel ordering, the channel connection hops, and the channel version. "),(0,r.kt)("p",null,"As part of the handling of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChanUpgradeInit")," message, the application's callbacks ",(0,r.kt)("inlineCode",{parentName:"p"},"OnChanUpgradeInit")," will be triggered as well."),(0,r.kt)("p",null,"After this message is handled successfully, the channel's upgrade sequence will be incremented. This upgrade sequence will serve as a nonce for the upgrade process to provide replay protection."),(0,r.kt)("h3",{id:"governance-gating-on-chanupgradeinit"},"Governance gating on ",(0,r.kt)("inlineCode",{parentName:"h3"},"ChanUpgradeInit")),(0,r.kt)("p",null,"The message signer for ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgChanUpgradeInit")," must be the address which has been designated as the ",(0,r.kt)("inlineCode",{parentName:"p"},"authority")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"IBCKeeper"),". If this proposal passes, the counterparty's channel will upgrade by default."),(0,r.kt)("p",null,"If chains want to initiate the upgrade of many channels, they will need to submit a governance proposal with multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgChanUpgradeInit"),"  messages, one for each channel they would like to upgrade, again with message signer as the designated ",(0,r.kt)("inlineCode",{parentName:"p"},"authority")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"IBCKeeper")),(0,r.kt)("h2",{id:"cancelling-a-channel-upgrade"},"Cancelling a Channel Upgrade"),(0,r.kt)("p",null,"Channel upgrade cancellation is performed by submitting a ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgChannelUpgradeCancel")," message."),(0,r.kt)("p",null,"It is possible for the authority to cancel an in-progress channel upgrade if the following are true:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The signer is the authority"),(0,r.kt)("li",{parentName:"ul"},"The channel state has not reached FLUSHCOMPLETE"),(0,r.kt)("li",{parentName:"ul"},"If the channel state has reached FLUSHCOMPLETE, an existence proof of an ",(0,r.kt)("inlineCode",{parentName:"li"},"ErrorReceipt")," on the counterparty chain is provided at our upgrade sequence or greater")),(0,r.kt)("p",null,"It is possible for a relayer to cancel an in-progress channel upgrade if the following are true:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An existence proof of an ",(0,r.kt)("inlineCode",{parentName:"li"},"ErrorReceipt")," on the counterparty chain is provided at our upgrade sequence or greater")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: if the signer is the authority, e.g. the ",(0,r.kt)("inlineCode",{parentName:"p"},"gov")," address, no ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorReceipt")," or proof is required if the current channel state is not in FLUSHCOMPLETE.\nThese can be left empty in the ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgChannelUpgradeCancel")," message in that case.")),(0,r.kt)("p",null,"Upon cancelling a channel upgrade, an ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorReceipt")," will be written with the channel's current upgrade sequence, and\nthe channel will move back to ",(0,r.kt)("inlineCode",{parentName:"p"},"OPEN")," state keeping its original parameters."),(0,r.kt)("p",null,"The application's ",(0,r.kt)("inlineCode",{parentName:"p"},"OnChanUpgradeRestore")," callback method will be invoked."),(0,r.kt)("p",null,"It will then be possible to re-initiate an upgrade by sending a ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgChannelOpenInit")," message."))}d.isMDXComponent=!0}}]);